# HUAWEI-CodeCraft2020
2020华为软挑武长赛区初赛rank5，复赛A榜rank4，B榜凉凉  \
**队伍：Dry_Martini_Shaken_Not_Stirred**  
**成绩：2.789（含0.2s的sleep）**  
# 大致思路  
## 建图
**(1)取点小tip**  
&emsp;&emsp;假设原始数据形式是`(x1,x2,x3)`，`x1`是转出方，`x2`是转入方，`x3`是转账金额。考虑到官方公布的练习数据中，很多点都有出度而没有入度，这些点在找环中是不需要考虑的。我们考虑使用一个`recordsort[2000000]`数组存储所有的`x2`，对其进行排序去重后剩下的点就是需要建立节点ID索引映射的点，而不再这其中的点是可以直接丢掉的，这样可以对图进行初步的剪枝。(但是对线上数据好像并没有什么用)    
**(2)图的存储**  
&emsp;&emsp;使用200w数组存储所有的边信息，边的形式为`(x1，x2，x3)`，含义同上。这样的数组需要两个，命名为`OutRecord`和`InRecord`，对`OutRecord`中的所有边按`x1`,`x2`的次序进行排序，排序后，计算`recordsort`中的每个点在`OutRecord`中`x1`位置上的开始位置索引`t1`和结束位置索引`t2`。此时，`OutRecord[t1]`和`OutRecord[t2]`之间的所有数据就是这个点的出度“邻接表”。    
&emsp;&emsp;同理，对`InRecord`进行相同的操作（之前对`x1`的操作现在均对`x2`），则可以建立每个点的入度“邻接表”。  
&emsp;&emsp;这样构图会比`vector`直接构建邻接表在线下19340345环的数据集上单线程快10s左右。  
&emsp;&emsp;进一步，排序后的`OutRecord`可以不存`x1`的信息，排序后的`InRecord`可以不存`x2`的信息，这样程序的运行时间又会比之前少一点。  
&emsp;&emsp;(复赛后拜读ddd大佬公布的建图方式，比我们考虑周到了很多，佩服佩服佩服…)    

## 输入  
&emsp;&emsp;输入用普通的`mmap`四线程读入，读入完后，对每个线程读取的`recordsort`进行预排序，之后再进行合并。  
（1）节点索引（映射）使用数组和`unordered_map`相结合的方式。鉴于线上ID可能大部分较小，开了个200w的数组，小于200w的ID使用数组映射，大于200w的ID再用`unordered_map`映射。  
（2）在索引建立后，建图、整数ID转字符串这三个操作可并行，为减少线程开销，可直接放在找环各线程之前，等数据处理完后再进行找环。  

## 找环
&emsp;&emsp;算法部分我们队值得说的地方很少…  
&emsp;&emsp;我们用的是朴素4+3，反向搜索三层的时候，用一个`bool`数组把倒数第三层节点记录下来，在正向搜索到`node5`的时候`（node1-node2-node3-node4-node5）`,先判断`node5`在bool数组中是否为true，为true则继续进行成环判断，否则直接continue，实测这样在线下19630345环的数据集上会比单纯反向三层快很多。  
&emsp;&emsp;**多线程均衡策略:** 使用一个`atomic_int MagicNode`表示当前还未进行搜索的第一个节点ID，每个线程搜索完当前任务后，读取`++MagicNode`得到本次搜索的任务节点。

## 输出
&emsp;&emsp;输出的两个过程：1.按要求的顺序取出各长度的环，并将`int`转存为字符串；2.写入txt文件。  
&emsp;&emsp;其中前者比较费时。多线程输出保证各线程均匀很重要，但算出绝对均分点的遍历过程很费时，这里采用一种大致均匀的分配方法，计算量非常小，却可以做到很均匀。每个长度的环在4个线程中都有一个单独的存环数组，找环时已统计各线程、各环数的20个的存环数组的数据长度（`int`型数据个数），这里直接拿来用。假如存三环的4个数组数据总长度为100，存四环的4个数组总长度为200，存五、六、七环的分别为200，200，300，那么20个数组总长度为1000，1/4均分点为250，即存在于四环中，且250 – 100 = 150为均分点在四环中的位置，该位置除以四环总长，为该位置在四环中的比例：150/200=0.75，也就是四环按该比例被分割到不同线程，然后将四环的4个线程数组按该比例分别分割，并分别找到分割点所在环的头节点，取4个头节点的平均值，即确定为最终的1/4分割头节点。就只需要告诉第0线程，你从三环起始开始，到四环的该头节点结束，就可以了。  
&emsp;&emsp;由于这种方法不会提前计算各线程`char`字符总数量，所以某线程在转存完后、在写入前，必须等前面的线程转存完毕，才能得到该线程写入文件的起始位置，这里使用`atomic_int Lenflag[]`记录起始位置，进行线程间通信。由于各线程分配基本均衡，所以这个等待过程时间很短。写入文件时，环数小于1w使用单线程`fwrite`写入，大于1w使用多线程`mmap`写入。  

# 感谢
&emsp;&emsp;感谢队友每天肝代码的付出。本队成员都是学机械的，每天一起摸索，一起进步...  
&emsp;&emsp;感谢**且随疾风前行**小队的黄同学和我们一直的交流。祝你们决赛顺利!  
&emsp;&emsp;感谢所有比赛的队伍，能与你们同台竞技，与有荣焉！

# 一件比赛趣事
&emsp;&emsp;初赛某天我们误操作把程序某处的`int`改成了`unsigned short`，结果竟然有分，从此我们知道了节点ID的小秘密。事实证明，运气也是生产力的一部分… 



